import { isIgnored, defineNuxtModule } from '@nuxt/kit';
import { stat, readFile, mkdir, writeFile } from 'node:fs/promises';
import { resolve, join } from 'node:path';
import { globby } from 'globby';
import _consola from 'consola';
import { existsSync } from 'node:fs';
import { colorize } from 'consola/utils';
import { createTar, parseTar } from 'nanotar';
import { objectHash, hash, murmurHash } from 'ohash';
import { provider } from 'std-env';

const consola = _consola.withTag("nuxt-build-cache");
async function readFilesRecursive(dir, opts = {}) {
  if (Array.isArray(dir)) {
    return (await Promise.all(dir.map((d) => readFilesRecursive(d, opts)))).flat();
  }
  const files = await globby(
    [...opts.patterns || ["**/*"], "!node_modules/**"],
    {
      cwd: dir
    }
  );
  const fileEntries = await Promise.all(
    files.map(async (fileName) => {
      if (opts.shouldIgnore?.(fileName)) {
        return;
      }
      return readFileWithMeta(dir, fileName, opts.noData);
    })
  );
  return fileEntries.filter(Boolean);
}
async function readFileWithMeta(dir, fileName, noData) {
  try {
    const filePath = resolve(dir, fileName);
    const stats = await stat(filePath);
    if (!stats?.isFile()) {
      return;
    }
    return {
      name: fileName,
      data: noData ? void 0 : await readFile(filePath),
      attrs: {
        mtime: stats.mtime.getTime(),
        size: stats.size
      }
    };
  } catch (err) {
    console.warn(
      `[nuxt-build-cache] Failed to read file \`${fileName}\`:`,
      err
    );
  }
}

const cacheDirs = {
  default: "node_modules/.cache/nuxt/builds",
  cloudflare_pages: ".next/cache/nuxt"
};
async function getHashes(nuxt) {
  if (nuxt._buildHash) {
    return nuxt._buildHash;
  }
  const hashSources = [];
  let layerCtr = 0;
  for (const layer of nuxt.options._layers) {
    if (layer.cwd.includes("node_modules")) {
      continue;
    }
    const layerName = `layer#${layerCtr++}`;
    hashSources.push({
      name: `${layerName}:config`,
      data: objectHash(layer.config)
    });
    const normalizeFiles = (files) => files.map((f) => ({
      name: f.name,
      size: f.attrs?.size,
      data: murmurHash(
        f.data
        /* ArrayBuffer */
      )
    }));
    const sourceFiles = await readFilesRecursive(layer.config?.srcDir, {
      shouldIgnore: isIgnored,
      // TODO: Validate if works with absolute paths
      patterns: [
        ...Object.values({
          ...nuxt.options.dir,
          ...layer.config.dir
        }).map((dir) => `${dir}/**`),
        "app.{vue,js,ts,cjs,mjs}",
        "App.{vue,js,ts,cjs,mjs}"
      ]
    });
    hashSources.push({
      name: `${layerName}:src`,
      data: normalizeFiles(sourceFiles)
    });
    const rootFiles = await readFilesRecursive(
      layer.config?.rootDir || layer.cwd,
      {
        shouldIgnore: isIgnored,
        // TODO: Validate if works with absolute paths
        patterns: [
          ".nuxtrc",
          ".npmrc",
          "package.json",
          "package-lock.json",
          "yarn.lock",
          "pnpm-lock.yaml",
          "tsconfig.json",
          "bun.lockb"
        ]
      }
    );
    hashSources.push({
      name: `${layerName}:root`,
      data: normalizeFiles(rootFiles)
    });
  }
  const res = nuxt._buildHash = {
    hash: hash(hashSources),
    sources: hashSources
  };
  return res;
}
async function getCacheStore(nuxt) {
  const hashes = await getHashes(nuxt);
  const cacheDir = join(
    nuxt.options.workspaceDir,
    cacheDirs[provider] || cacheDirs.default,
    hashes.hash
  );
  const cacheFile = join(cacheDir, "nuxt.tar");
  return {
    hashes,
    cacheDir,
    cacheFile
  };
}
async function collectBuildCache(nuxt) {
  const { cacheDir, cacheFile, hashes } = await getCacheStore(nuxt);
  await mkdir(cacheDir, { recursive: true });
  await writeFile(
    join(cacheDir, "hashes.json"),
    JSON.stringify(hashes, void 0, 2)
  );
  const start = Date.now();
  consola.start(
    `Collecting nuxt build cache 
  - from \`${nuxt.options.buildDir}\``
  );
  const fileEntries = await readFilesRecursive(nuxt.options.buildDir, {
    patterns: ["**/*", "!analyze/**"]
  });
  const tarData = await createTar(fileEntries);
  await _cfPagesHack(nuxt.options.workspaceDir);
  await writeFile(cacheFile, tarData);
  consola.success(
    `Nuxt build cache collected in \`${Date.now() - start}ms\` 
  - to \`${cacheDir}\`
` + colorize("gray", fileEntries.map((e) => `  \u25A3 ${e.name}`).join("\n"))
  );
}
async function restoreBuildCache(nuxt) {
  const { cacheFile, cacheDir } = await getCacheStore(nuxt);
  if (!existsSync(cacheFile)) {
    consola.info(`No build cache found 
  - in \`${cacheFile}\``);
    return false;
  }
  const start = Date.now();
  consola.start(`Restoring nuxt from build cache 
  - from: \`${cacheDir}\``);
  const files = parseTar(await readFile(cacheFile));
  for (const file of files) {
    const filePath = join(nuxt.options.buildDir, file.name);
    if (existsSync(filePath)) {
      const stats = await stat(filePath);
      if (stats.mtime.getTime() >= (file.attrs?.mtime || 0)) {
        consola.debug(
          `Skipping \`${file.name}\` (up to date or newer than cache)`
        );
        continue;
      }
    }
    await mkdir(join(filePath, ".."), { recursive: true });
    await writeFile(filePath, file.data);
  }
  consola.success(
    `Nuxt build cache restored in \`${Date.now() - start}ms\` 
  - into: \`${nuxt.options.buildDir}\``
  );
  return true;
}
async function _cfPagesHack(dir) {
  if (provider === "cloudflare_pages") {
    const { readPackageJSON, writePackageJSON } = await import('pkg-types');
    const pkg = await readPackageJSON(dir).catch(() => void 0);
    await writePackageJSON(join(dir, "package.json"), {
      ...pkg,
      devDependencies: {
        ...pkg?.devDependencies,
        next: "npm:just-a-placeholder@0.0.0"
      }
    });
  }
}

const module = defineNuxtModule({
  async setup(_, nuxt) {
    if (nuxt.options._prepare || nuxt.options.dev || process.env.NUXT_DISABLE_BUILD_CACHE) {
      return;
    }
    nuxt.hook("build:before", async () => {
      const restored = process.env.NUXT_IGNORE_BUILD_CACHE ? void 0 : await restoreBuildCache(nuxt);
      if (restored) {
        nuxt.options.builder = {
          bundle() {
            consola.info("skipping build");
            return Promise.resolve();
          }
        };
      } else {
        if (!process.env.SKIP_NUXT_BUILD_CACHE_COLLECT) {
          nuxt.hook("close", async () => {
            await collectBuildCache(nuxt);
          });
        }
      }
    });
  }
});

export { module as default };
